# Dev workflow (v0)

Документ фиксирует правила разработки и окружений для версии v0.


## 1. Окружения

## Архитектурное решение: ввод опыта (v0)

В версии v0 сервис принимает **только текстовый ввод** от пользователя.

Текст может быть получен:
- через обычный набор с клавиатуры;
- через голосовую диктовку на стороне устройства пользователя (системная функция клавиатуры iOS/Android).

Сервис **не выполняет распознавание речи (ASR)** в версии v0.
Распознавание речи, если используется голосовой ввод, происходит **на стороне устройства пользователя** и в сервис передаётся уже готовый текст.

### Обоснование решения

- Современные мобильные ОС и клавиатуры предоставляют стабильный и удобный режим голосовой диктовки.
- Это позволяет пользователю вводить опыт голосом без внедрения серверного ASR.
- Снижается сложность архитектуры и стоимость поддержки v0.
- NLP-пайплайн сервиса (extractor, embeddings, поиск) начинается с `raw_text` и не зависит от способа его получения.

### Следствия для архитектуры

- `raw_text` является основным входным полем для фиксации опыта и запросов.
- Аудио-данные не передаются и не хранятся на сервере в v0.
- Возможность серверного ASR рассматривается как опциональное расширение для следующих версий и не блокирует текущую архитектуру.

### Stage = локально
- Stage-окружение существует **только локально** на машине разработчика.
- Stage поднимается через Docker Compose (или эквивалент), чтобы обеспечить повторяемость.
- Все ключевые компоненты работают локально:
  - база данных
  - векторное хранилище
  - NLP/LLM extractor
  - embeddings / vectorization

### Prod = сервер
- На сервере размещается **только production**.
- Никакого staging на сервере.
- Прод должен быть максимально стабильным: только проверенные изменения из `main`.

## 2. Источник правды и синхронизация

- **GitHub — единственный источник правды** для:
  - кода
  - схем/контрактов
  - промптов
  - миграций БД
  - конфигурационных шаблонов
- Модели и большие артефакты **не храним в Git** (см. раздел 6).

## 3. Ветки и PR

### Ветки
- `main` — продовая ветка (только то, что можно деплоить).
- Feature/bugfix ветки:
  - `feat/<short-name>`
  - `fix/<short-name>`

> Если потребуется интеграционная ветка — добавим `dev`, но по умолчанию работаем проще: feature → PR → main.

### PR правила (минимальный чек-лист)
- PR должен содержать:
  - краткое описание (что сделано и зачем)
  - список затронутых сервисов/контрактов
  - заметку, если менялись схемы/миграции
- Никаких "тихих" изменений контрактов: если меняется формат данных/схема — это явно отражается в PR.

## 4. Локальный запуск (Stage)

### Базовый принцип
- Один командный сценарий должен поднимать систему целиком локально.
- Предпочтительно: `docker compose up` (название файла и сервисов уточняется по факту структуры репозитория).

### Данные
- В stage можно использовать локальные тома Docker для:
  - Postgres данных
  - индекса pgvector
- Важно: тестовые данные можно сбрасывать, prod данные — нет.

## 5. CI (GitHub Actions)

На каждый PR в `main` должен выполняться минимальный CI:
- lint/format (если настроено)
- unit tests (если есть)
- сборка (или хотя бы проверка) docker-образов/compose-конфига

Цель CI в v0: не "идеальные тесты", а гарантия, что проект **собирается и не сломан**.

## 6. Модели и артефакты (локально, но не в Git)

### Политика
- Большие файлы моделей не коммитим в репозиторий.
- В репозитории храним:
  - список используемых моделей и версии
  - скрипт/инструкцию скачивания
  - (опционально) checksums

### Рекомендуемый подход
- `scripts/pull_models.sh` (или аналог) скачивает модели в локальную директорию, например:
  - `.models/`
- `.models/` добавляется в `.gitignore`.

> В v0 допускается ручная установка моделей по инструкции, но предпочтительнее скрипт.

## 6.1 Версионирование моделей

Для воспроизводимости в v0:
- используемые модели (ASR, LLM extractor, embeddings) фиксируются в конфигурации проекта
- для каждой модели указывается:
  - model_id
  - версия или хеш
  - назначение (ASR / extractor / embeddings)

Рекомендуется хранить эту информацию в одном месте (например, `configs/models.yaml`),
чтобы было понятно, какие модели используются в конкретной версии `main`.

## 7. Конфигурация и секреты

### Stage
- Конфиги можно хранить в `.env` (локально), но:
  - `.env` не коммитим
  - коммитим `.env.example`

### Prod
- Секреты и прод-конфигурация хранятся только на сервере (env vars / secrets manager).
- В GitHub не должно быть прод-ключей.

## 8. Деплой на Prod

- Деплой осуществляется **только из `main`**.
- Варианты:
  - manual deploy (ручной запуск workflow/скрипта)
  - auto deploy (по merge в `main`) — включим, когда стабилизируем пайплайн

### Технический формат деплоя

- Продакшн разворачивается в виде контейнеров.
- Базовый вариант для v0: Docker Compose на сервере.
- Все сервисы и версии образов фиксируются в `docker-compose.prod.yml`.
- Обновление продакшна = pull актуального `main` + пересборка/перезапуск контейнеров.

Минимальное требование: должно быть понятно, какая версия `main` сейчас в проде (commit hash / tag).

## 9. Контракты и совместимость

Для v0 критично:
- все контракты (JSON schema, API) версионируются через Git
- изменения контрактов должны быть обратимо совместимыми или сопровождаться миграцией
- raw данные (audio/text) сохраняем, чтобы можно было переобрабатывать структурирование при смене моделей
- любые изменения схемы БД выполняются только через миграции

## 10. Миграции базы данных

- Все изменения схемы БД оформляются как миграции и хранятся в репозитории.
- Миграции должны быть идемпотентными и применимыми локально (stage).
- Перед запуском системы в stage разработчик обязан прогнать актуальные миграции.
- В prod миграции применяются строго перед запуском новой версии сервисов.
